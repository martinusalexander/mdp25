package mdp;

import java.util.Scanner;

public class Robot {
	
	//MODE
	private static final int IDLE_MODE = 900;
	private static final int EXPLORE_MODE = 901;
	private static final int FASTEST_MODE = 902;
	
	//DIRECTION
	private static final int HEADING_UP = 0;
	private static final int HEADING_RIGHT = 90;
	private static final int HEADING_DOWN = 180;
	private static final int HEADING_LEFT = 270;
	
	//LIST OF ACTION
	public static final int MOVE_FORWARD = 800;
	public static final int MOVE_BACKWARD = 801;
	public static final int TURN_LEFT = 802;
	public static final int TURN_RIGHT = 803;
	public static final int TURN_180 = 804;
	public static final int CHECK_OBSTACLE_IN_FRONT = 805;
	public static final int CHECK_OBSTACLE_ON_LEFT = 806;
	public static final int CHECK_OBSTACLE_ON_RIGHT = 807;
	public static final int EXPLORE = 808;
	public static final int FASTEST_RUN = 809;
	
	//INITIAL POSITION AND DIRECTION
	private static final int DESIRED_INITIAL_X_LOCATION = 0;
	private static final int DESIRED_INITIAL_Y_LOCATION = 0;
	private static final int DESIRED_INITIAL_DIRECTION = HEADING_DOWN;
	
	private int xLocation;
	private int yLocation;
	private int direction;
	private boolean isCalibrated;
	private int mode;
	
	public Robot() {
		this.xLocation = 0;
		this.yLocation = 0;
		this.direction = HEADING_DOWN;
		this.isCalibrated = false;
		this.mode = IDLE_MODE;
	}
	
	public Robot(int startingXLocation, int startingYLocation, int direction) {
		this.xLocation = startingXLocation;
		this.yLocation = startingYLocation;
		this.direction = direction;
		this.isCalibrated = false;
		this.mode = IDLE_MODE;
	}
	
	private boolean explore() {
		this.mode = EXPLORE_MODE;
		do {
			calibrateInitialPosition();
		} while (!isCalibrated);
		//Code here
		
		
		//Finished
		this.mode = IDLE_MODE;
		return true;
		
	}
	
	private boolean fastestRun() {
		this.mode = FASTEST_MODE;
		do {
			calibrateInitialPosition();
		} while (!isCalibrated);
		//Code here
		
		//Finishing
		this.mode = IDLE_MODE;
		return true;
	}
	
	private void calibrateInitialPosition() {
		if (xLocation != DESIRED_INITIAL_X_LOCATION && yLocation != DESIRED_INITIAL_Y_LOCATION && direction != DESIRED_INITIAL_DIRECTION) {
			System.out.println("Robot is put in the incorrect position or incorrect direction");
			correctRobotPosition();
			return;
		} else {
			//TODO (command Arduino)
			isCalibrated = true;
		}
	}
	
	private void correctRobotPosition() {
		Scanner scanner = new Scanner(System.in);
		System.out.print("Re-enter X location: ");
		this.xLocation = scanner.nextInt();
		System.out.print("Re-enter Y location: ");
		this.yLocation = scanner.nextInt();
		System.out.println("Select direction:");
		System.out.println("1. Heading up");
		System.out.println("2. Heading down");
		System.out.println("3. Heading left");
		System.out.println("4. Heading right");
		System.out.print("Re-enter direction: ");
		int userInput = 0;
		do{
			userInput = scanner.nextInt();
			switch (userInput) {
				case 1: direction = HEADING_UP; break;
				case 2: direction = HEADING_DOWN; break;
				case 3: direction = HEADING_LEFT; break;
				case 4: direction = HEADING_RIGHT; break;
				default: System.out.print("Re-enter direction: "); break;
			}
		} while (!(1 <= userInput && userInput <= 4));
	}
	
	private boolean command(int commandType) {
		boolean result = false;
		switch (commandType) {
			case EXPLORE: result = explore(); break;
			case FASTEST_RUN: result = fastestRun(); break;
			case TURN_LEFT: result = turnLeft(); break;
			case TURN_RIGHT: result = turnRight(); break;
			case MOVE_FORWARD:  result = moveForward(); break;
			case MOVE_BACKWARD: result = moveBackward(); break;
			case TURN_180: turnLeft(); result = turnLeft(); break;
			case CHECK_OBSTACLE_IN_FRONT: result = checkObstacleInFront(); break;
			case CHECK_OBSTACLE_ON_LEFT: result = checkObstacleOnLeft(); break;
			case CHECK_OBSTACLE_ON_RIGHT: result = checkObstacleOnRight(); break;
			default: result = false; break;
		}
		return result;
	}
	
	private boolean turnLeft() {
		this.direction -= 90;
		this.direction %= 360;
		//TODO (command Arduino)
		return true;
	}
	
	private boolean turnRight() {
		this.direction += 90;
		this.direction %= 360;
		//TODO (command Arduino)
		return true;
	}
	
	private boolean moveForward() {
		if (mode == EXPLORE_MODE) {
			//TODO (command Arduino) -> move half grid, then check left & right, then move half grid
			checkObstacleOnLeft();
			checkObstacleOnRight();
		} else {
			//TODO (command Arduino) -> move one grid
		}
		switch (direction) {
			case HEADING_UP: this.xLocation += 1; break;
			case HEADING_DOWN: this.xLocation -= 1; break;
			case HEADING_LEFT: this.yLocation -= 1; break;
			case HEADING_RIGHT: this.yLocation += 1; break;
		}
		return true;
	}
	
	private boolean moveBackward() {
		switch (direction) {
			case HEADING_UP: this.xLocation -= 1; break;
			case HEADING_DOWN: this.xLocation += 1; break;
			case HEADING_LEFT: this.yLocation += 1; break;
			case HEADING_RIGHT: this.yLocation -= 1; break;
		}
		//TODO (command Arduino)
		return true;
	}
	
	private boolean checkObstacleInFront() {
		boolean obstacleInFrontLeft2GridAway = false;
		boolean obstacleInFrontRight2GridAway = false;
		boolean obstacleInFrontLeft = false;
		boolean obstacleInFrontRight = false;
		//TODO (command Arduino)
		if (obstacleInFrontLeft2GridAway) {
			switch (direction) {
				case HEADING_UP: 
					App.arena.getGrid(this.xLocation, this.yLocation+3).markAsObstacle();
					break;
				case HEADING_DOWN: 
					App.arena.getGrid(this.xLocation+1, this.yLocation-2).markAsObstacle();
					break;
				case HEADING_LEFT:
					App.arena.getGrid(this.xLocation-2, this.yLocation).markAsObstacle();
					break;
				case HEADING_RIGHT:
					App.arena.getGrid(this.xLocation+3, this.yLocation+1).markAsObstacle();
					break;
			}
		} else if (obstacleInFrontLeft) {
			switch (direction) {
				case HEADING_UP: 
					App.arena.getGrid(this.xLocation, this.yLocation+2).markAsObstacle();
					break;
				case HEADING_DOWN: 
					App.arena.getGrid(this.xLocation+1, this.yLocation-1).markAsObstacle();
					break;
				case HEADING_LEFT:
					App.arena.getGrid(this.xLocation-1, this.yLocation).markAsObstacle();
					break;
				case HEADING_RIGHT:
					App.arena.getGrid(this.xLocation+2, this.yLocation+1).markAsObstacle();
					break;
			}
		}
		if (obstacleInFrontRight2GridAway) {
			switch (direction) {
				case HEADING_UP: 
					App.arena.getGrid(this.xLocation+1, this.yLocation+3).markAsObstacle();
					break;
				case HEADING_DOWN: 
					App.arena.getGrid(this.xLocation, this.yLocation-2).markAsObstacle();
					break;
				case HEADING_LEFT:
					App.arena.getGrid(this.xLocation-2, this.yLocation+1).markAsObstacle();
					break;
				case HEADING_RIGHT:
					App.arena.getGrid(this.xLocation+3, this.yLocation).markAsObstacle();
					break;
			}
		} else if (obstacleInFrontRight) {
			switch (direction) {
				case HEADING_UP: 
					App.arena.getGrid(this.xLocation+1, this.yLocation+2).markAsObstacle();
					break;
				case HEADING_DOWN: 
					App.arena.getGrid(this.xLocation, this.yLocation-1).markAsObstacle();
					break;
				case HEADING_LEFT:
					App.arena.getGrid(this.xLocation, this.yLocation+1).markAsObstacle();
					break;
				case HEADING_RIGHT:
					App.arena.getGrid(this.xLocation+2, this.yLocation).markAsObstacle();
					break;
			}
		}
		
		return (obstacleInFrontLeft2GridAway || obstacleInFrontRight2GridAway ||
				obstacleInFrontLeft || obstacleInFrontRight);
	}
	
	private boolean checkObstacleOnLeft() {
		boolean obstacleOnLeft = false;
		//Assuming that the current location is still previous location instead of new location
		if (obstacleOnLeft) {
			switch (direction) {
				case HEADING_UP:
					App.arena.getGrid(this.xLocation-1, this.yLocation+1).markAsObstacle();
					break;
				case HEADING_DOWN:
					App.arena.getGrid(this.xLocation+2, this.yLocation).markAsObstacle();
					break;
				case HEADING_LEFT:
					App.arena.getGrid(this.xLocation, this.yLocation-1).markAsObstacle();
					break;
				case HEADING_RIGHT:
					App.arena.getGrid(this.xLocation+1, this.yLocation+2).markAsObstacle();
					break;
			}	
		}
		return obstacleOnLeft;
	}
	
	private boolean checkObstacleOnRight() {
		boolean obstacleOnRight = false;
		//Assuming that the current location is still previous location instead of new location
		if (obstacleOnRight) {
			switch (direction) {
				case HEADING_UP:
					App.arena.getGrid(this.xLocation+2, this.yLocation+1).markAsObstacle();
					break;
				case HEADING_DOWN:
					App.arena.getGrid(this.xLocation-1, this.yLocation).markAsObstacle();
					break;
				case HEADING_LEFT:
					App.arena.getGrid(this.xLocation, this.yLocation+2).markAsObstacle();
					break;
				case HEADING_RIGHT:
					App.arena.getGrid(this.xLocation+1, this.yLocation-1).markAsObstacle();
					break;
			}
		}
		
		return obstacleOnRight;
	}
}
